---
title: "RProgrammingWeek3"
author: "Serge Ballif"
date: "May 16, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

### lapply
- lapply: loop over a list and evaluate a function
- sapply: same as lapply but try to simplify the result
- apply Apply a function over the margins of an array
- tapply Apply a function of a subsets of a vector
- mapply multivariate version of lapply
- split splits objects into subpieces.


```{r}
lapply
```
`lapply` always returns a list regarless of the class of the input.
```{r}
x <- list(a = 1:5, b = rnorm(10))
x
lapply(x, mean)
```

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
```

```{r}
x<-1:4
lapply(x,runif) #generates x random variables
lapply(x, runif, min = 0, max = 10)# changes mu and sigma
```

```{r}
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
x

lapply(x, function(elt) elt[,1]) # gets first column of elements
```

`sapply` will try to simplify the result of `lapply`. For example it will often return a vector instead of a list.

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean)
```

### apply
`apply` is used to apply a function to the rows or columns of a matrix. It can even be used with an array of matrices. It is the same speed as a loop

```{r}
str(apply)
```

```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean) # takes mean across all 10 columns
apply(x, 1, sum) # Finds sum across all 20 rows
```

Shortcuts:
- `rowSums=apply(x,1,sum)`
- `rowMeans=apply(x,1,mean)`
- `colSums=apply(x,2,sum)`
- `colMeans=apply(x,2,mean)`
These evaluate faster than apply.

We can get the 1st and 3rd quantiles with the code below (a 20x2 matrix)
```{r}
apply(x, 1, quantile, probs = c(0.25, 0.75))
```

Average of a bunch of 2x2 matrices:
```{r}
 a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean) #collapses 3rd dimension and gives a matrix of means
rowMeans(a, dims = 2)
```

### mapply
`mapply` is a multivariate apply of sorts which applies a function in parallel over a set of arguments.
```{r}
str(mapply)
```

```{r}
# rep function repeats a value
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
mapply(rep,1:4,4:1)
```

```{r}
noise <- function(n, mean, sd) {
  rnorm(n, mean, sd)
  }
noise(5, 1, 2)
noise(1:5,1:5,2) #doesn't work
mapply(noise, 1:5, 1:5, 2)# vectorized function
list(noise(1, 1, 2), noise(2, 2, 2),
 noise(3, 3, 2), noise(4, 4, 2),
 noise(5, 5, 2))# same definition
```

## tapply
`tapply` is used to apply a function over subsets of a vector. I don’t know why it’s called tapply.
```{r}
str(tapply)
```

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1)) # 10 normals, 10 uniforms, 10 normals
f <- gl(3, 10) # factor variable with 3 levels
f
tapply(x,f,mean)
tapply(x,f,mean,simplify=FALSE)
tapply(x,f,range) #returns the range of values for each level
```

## split
`split` takes a vector or other objects and splits it into groups determined by a factor or list of factors. Like `tapply` but without the summary stats.

```{r}
str(split)
```


```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x,f)
lapply(split(x, f), mean) # could be done using tapply
```

```{r}
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])) # simplified result
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],na.rm = TRUE))
```

```{r}
x <- rnorm(10)
f1 <- gl(2, 5) # two levels: male, female
f2 <- gl(5, 2) # 5 levels: race
f1
f2
interaction(f1,f2) # new factor with 10 levels

str(split(x, list(f1, f2))) # some levels may be empty
str(split(x, list(f1, f2), drop = TRUE))# remove empty levels
```

## Debugging
- `message:` A generic notification/diagnostic message produced by the message function;
execution of the function continues
- `warning:` An indication that something is wrong but not necessarily fatal; execution of the
function continues; generated by the warning function
- `error:` An indication that a fatal problem has occurred; execution stops; produced by the stop
function
- `condition:` A generic concept for indicating that something unexpected can occur; programmers
can create their own conditions

```{r}
log(-1)
```

```{r}
printmessage <- function(x) {
 if(x > 0)
 print("x is greater than zero")
 else
 print("x is less than or equal to zero")
 invisible(x) # a function that prevents autoprinting
}
printmessage(1)
#printmessage(NA)
```

```{r}
printmessage2 <- function(x) {
 if(is.na(x))
 print("x is a missing value!")
 else if(x > 0)
 print("x is greater than zero")
 else
 print("x is less than or equal to zero")
 invisible(x)
}
```

How do you know that something is wrong with your function?
- What was your input? How did you call the function?
- What were you expecting? Output, messages, other results?
- What did you get?
- How does what you get differ from what you were expecting?
- Were your expectations correct in the first place?
- Can you reproduce the problem (exactly)?`

## Debugging Tools
The primary tools for debugging functions in R are
These are interactive tools specifically designed to allow you to pick through a function. There’s also
the more blunt technique of inserting print/cat statements in the function.
- `traceback:` prints out the function call stack after an error occurs; does nothing if there’s no error
- `debug:` flags a function for “debug” mode which allows you to step through execution of a function
one line at a time
- `browser:` suspends the execution of a function wherever it is called and puts the function in
debug mode
- `trace:` allows you to insert debugging code into a function at specific places
- `recover:` allows you to modify the error behavior so that you can browse the function call stack

```{r}
mean(x)
traceback()
 
#lm(y~x) # linear modeling function
#traceback()
#debug(lm)
#lm(y~x)

options(error=recover)
#read.csv("nosuchfile")
```

### swirl lapply and sapply
```{r, eval=FALSE}
cls_list <- lapply(flags, class)
cls_list
as.character(cls_list) # make a character vector
cls_vect <- sapply(flags,class)
get total v
sum(flags$orange) #add up the 1's in the orange column to get number of orange flags
flag_colors <- flags[, 11:17] # Get colors from columns 11:17
head(flag_colors)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[, 19:23] # Get shapes of flags from columns 19:23
lapply(flag_shapes,range)
shape_mat<-sapply(flag_shapes,range)
unique(c(3, 4, 5, 5, 5, 6, 6)) # removes duplicates
unique_vals <- lapply(flags, unique) # get unique values for each variable in the flags dataset.
lapply(unique_vals, function(elem) elem[2]) # returns the second value in the list of unique vals
```
