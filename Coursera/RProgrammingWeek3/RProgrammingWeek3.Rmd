---
title: "RProgrammingWeek3"
author: "Serge Ballif"
date: "May 16, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

### lapply
- lapply: loop over a list and evaluate a function
- sapply: same as lapply but try to simplify the result
- apply Apply a function over the margins of an array
- tapply Apply a function of a subsets of a vector
- mapply multivariate version of lapply
- split splits objects into subpieces.


```{r}
lapply
```
`lapply` always returns a list regarless of the class of the input.
```{r}
x <- list(a = 1:5, b = rnorm(10))
x
lapply(x, mean)
```

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
```

```{r}
x<-1:4
lapply(x,runif) #generates x random variables
lapply(x, runif, min = 0, max = 10)# changes mu and sigma
```

```{r}
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
x

lapply(x, function(elt) elt[,1]) # gets first column of elements
```

`sapply` will try to simplify the result of `lapply`. For example it will often return a vector instead of a list.

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean)
```

### apply
`apply` is used to apply a function to the rows or columns of a matrix. It can even be used with an array of matrices. It is the same speed as a loop

```{r}
str(apply)
```

```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean) # takes mean across all 10 columns
apply(x, 1, sum) # Finds sum across all 20 rows
```

Shortcuts:
- `rowSums=apply(x,1,sum)`
- `rowMeans=apply(x,1,mean)`
- `colSums=apply(x,2,sum)`
- `colMeans=apply(x,2,mean)`
These evaluate faster than apply.

We can get the 1st and 3rd quantiles with the code below (a 20x2 matrix)
```{r}
apply(x, 1, quantile, probs = c(0.25, 0.75))
```

Average of a bunch of 2x2 matrices:
```{r}
 a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean) #collapses 3rd dimension and gives a matrix of means
rowMeans(a, dims = 2)
```

### mapply
`mapply` is a multivariate apply of sorts which applies a function in parallel over a set of arguments.
```{r}
str(mapply)
```

```{r}
# rep function repeats a value
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
mapply(rep,1:4,4:1)
```

```{r}
noise <- function(n, mean, sd) {
  rnorm(n, mean, sd)
  }
noise(5, 1, 2)
noise(1:5,1:5,2) #doesn't work
mapply(noise, 1:5, 1:5, 2)# vectorized function
list(noise(1, 1, 2), noise(2, 2, 2),
 noise(3, 3, 2), noise(4, 4, 2),
 noise(5, 5, 2))# same definition
```

## tapply
`tapply` is used to apply a function over subsets of a vector. I don’t know why it’s called tapply.
```{r}
str(tapply)
```

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1)) # 10 normals, 10 uniforms, 10 normals
f <- gl(3, 10) # factor variable with 3 levels
f
tapply(x,f,mean)
tapply(x,f,mean,simplify=FALSE)
tapply(x,f,range) #returns the range of values for each level
```

## split
`split` takes a vector or other objects and splits it into groups determined by a factor or list of factors. Like `tapply` but without the summary stats.

```{r}
str(split)
```


```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x,f)
lapply(split(x, f), mean) # could be done using tapply
```

```{r}
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])) # simplified result
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],na.rm = TRUE))
```

```{r}
x <- rnorm(10)
f1 <- gl(2, 5) # two levels: male, female
f2 <- gl(5, 2) # 5 levels: race
f1
f2
interaction(f1,f2) # new factor with 10 levels

str(split(x, list(f1, f2))) # some levels may be empty
str(split(x, list(f1, f2), drop = TRUE))# remove empty levels
```

## Debugging
- `message:` A generic notification/diagnostic message produced by the message function;
execution of the function continues
- `warning:` An indication that something is wrong but not necessarily fatal; execution of the
function continues; generated by the warning function
- `error:` An indication that a fatal problem has occurred; execution stops; produced by the stop
function
- `condition:` A generic concept for indicating that something unexpected can occur; programmers
can create their own conditions

```{r}
log(-1)
```

```{r}
printmessage <- function(x) {
 if(x > 0)
 print("x is greater than zero")
 else
 print("x is less than or equal to zero")
 invisible(x) # a function that prevents autoprinting
}
printmessage(1)
#printmessage(NA)
```

```{r}
printmessage2 <- function(x) {
 if(is.na(x))
 print("x is a missing value!")
 else if(x > 0)
 print("x is greater than zero")
 else
 print("x is less than or equal to zero")
 invisible(x)
}
```

How do you know that something is wrong with your function?
- What was your input? How did you call the function?
- What were you expecting? Output, messages, other results?
- What did you get?
- How does what you get differ from what you were expecting?
- Were your expectations correct in the first place?
- Can you reproduce the problem (exactly)?`

## Debugging Tools
The primary tools for debugging functions in R are
These are interactive tools specifically designed to allow you to pick through a function. There’s also the more blunt technique of inserting print/cat statements in the function.

- `traceback:` prints out the function call stack after an error occurs; does nothing if there’s no error
- `debug:` flags a function for “debug” mode which allows you to step through execution of a function
one line at a time
- `browser:` suspends the execution of a function wherever it is called and puts the function in
debug mode
- `trace:` allows you to insert debugging code into a function at specific places
- `recover:` allows you to modify the error behavior so that you can browse the function call stack

```{r}
mean(x)
traceback()
 
#lm(y~x) # linear modeling function
#traceback()
#debug(lm)
#lm(y~x)

options(error=recover)
#read.csv("nosuchfile")
```

### swirl lapply and sapply
```{r, eval=FALSE}
cls_list <- lapply(flags, class)
cls_list
as.character(cls_list) # make a character vector
cls_vect <- sapply(flags,class)
get total v
sum(flags$orange) #add up the 1's in the orange column to get number of orange flags
flag_colors <- flags[, 11:17] # Get colors from columns 11:17
head(flag_colors)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[, 19:23] # Get shapes of flags from columns 19:23
lapply(flag_shapes,range)
shape_mat<-sapply(flag_shapes,range)
unique(c(3, 4, 5, 5, 5, 6, 6)) # removes duplicates
unique_vals <- lapply(flags, unique) # get unique values for each variable in the flags dataset.
lapply(unique_vals, function(elem) elem[2]) # returns the second value in the list of unique vals

vapply(flags, class, character(1)) # gets same as sapply(flags, class)
table(flags$landmass) # gives the number of flags on each continent
table(flags$animate) # gives the number of flags with/without an animate image
tapply(flags$animate, flags$landmass, mean) # applies the mean function to 
# the 'animate' variable separately for each of the six landmass groups, thus giving us the proportion of flags containing an animate image WITHIN each landmass group

tapply(flags$population, flags$red, summary)
# summary of population values (in round millions) for countries with and without the color red on their flag

tapply(flags$population, flags$landmass, summary)
# summary of population values for each of the six landmasses
```


## Week 3 Quiz
Take a look at the 'iris' dataset that comes with R. The data can be loaded with the code:

```{r eval=FALSE}
library(datasets)
data(iris)
```
A description of the dataset can be found by running
```{r eval=FALSE}
?iris
```
There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.
 
```{r}
sp <- split(iris,iris$Species)
mean(sp$virginica$Sepal.Length)
```

Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'

```{r}
apply(iris[, 1:4], 2, mean)
# The number 2 indicates that the means of columns are computed. To get a mean of the row use a 1.
```

Load the 'mtcars' dataset in R with the following code
```{r}
library(datasets)
data(mtcars)
```
There will be an object names 'mtcars' in your workspace. You can find some information about the dataset by running
```{r}
?mtcars
```
How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)?
```{r}
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$mpg,mtcars$cyl,mean)
with(mtcars, tapply(mpg, cyl, mean))
```

Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?

```{r}
HPbyCyl<-tapply(mtcars$hp, mtcars$cyl, mean)
HPbyCyl['8']-HPbyCyl['4']
```
